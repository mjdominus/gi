
* PHILOSOPHY

Everything gi *does* is compatible with git.

But it will be pedagogically simple and conceptually clear.

* FOR EXAMPLE

Maybe "git commit file" is convenient.
But it's complex and philosophically confusing.
So we aren't going to do it.
"gi commit" commits THE INDEX.
If you want "git commit file", you know where to find it.

Similarly, "gi commit" is forbidden when the HEAD is detached.
Sometimes it's useful to commit when the HEAD is detached.
If you want to do that, you can use git-commit.

* BASIC CONCEPTS THAT WE EMPHASIZE

HEAD
  head ref
  head commit

The index
  We commit THE INDEX.
  We DO NOT commit "changes".
  We DO NOT commit "a file".

  The terminology here is a mess:

  Do not refer to the index as "the stage" or "the cache".
  Do not refer to indexed changes as "staged" or "cached"?
  Or if you do, pick one and stick with it!
    Don't say "the staged changes" unless you have recently used the longer form
    "The changes staged in the index".

Branches
  A branch is a named commit plus all its ancestor commits.
  Thus some branches contain others.

* Stuff that confuses beginners:

** Detached head

We'll fix this with explicit gi-detach and gi-attach commands.
Instead there's some suite for copying a commit to the index, for
copying the index to the working tree, and gi-go for moving HEAD to a
new commit.

There is always a headref unless you *explicitly* use gi-detach.

** Rejected PUSH

I think this is unavoidable complexity and that git's treatment of
this is correct. Beginners will have to deal with it.  But think about
it anyway; maybe there's some way we can clean it up.

Maybe something to offer helpful advice about what to do.

* COMMANDS

** gi-go <ref>

Attach HEAD to some other ref:

       HEAD now attached to <ref>

The commit pointed to by the old headref doesn't change.

If HEAD was detached, it is attached, that's OK.

** gi-detach

Basically git-checkout HEAD~0.  Message is "HEAD detached" or "HEAD
was already detached".

** gi-branch <name>

Make a new ref at the current head commit.

-a flag attaches to the new ref.

** gi-commit 

Commits the index and moves the 

Forbidden when in a detached HEAD state.

** gi-move <ref> <commit-ish>

Moves an existing ref to a new commit.  Work could be lost.  Dangerous?
If you do supply this, have it leave behind OLDLOC or something.

** gi-checkout <ref>

Attaches the HEAD to the specified ref.
Then copy the head commit to the index, then to the working directory.

Forbidden if the index or working tree are dirty.

** gi-discard-changes

Discards working tree changes: copies the index to the working tree.

(Optional files: copy only those files?)

** gi-reset-index

Discards index changes: copies the head commit to the index.

(Optional files: copy only those files?)

** git commands that we will pass through to gi unchanged

    gi-cherry-pick
    gi-rebase
    gi-rebase--interactive
    gi-status
    gi-status--short

    gi-merge
    gi-grep
    gi-log

    Most of the remote repo commands:
    gi-fetch
    gi-clone

** git commands where we should change the interface or the options or something

*** gi-diff

It's hard to guess which two things will be compared.  Try to rationalize the argmuents:

     gi diff commitish-A commitish-B
     gi diff             commitish-B    (commitish-A is taken to be HEAD)
     gi diff INDEX                      ("INDEX" is treated specially)

     gi ix                              (Synonym for 'gi diff INDEX'? 
                                         probably not; if they want
                                         that they can make an alias.
                                         Do not multiply entities.)


*** gi-push

I found the distinction between the ref and the remote name confusing.
We can probably clean up the interface here.  Also get a better syntax
for things like "localref:remoteref".  Maybe the remote is *always*
assumed to be 'origin' unless you use a '--remote=foo' option or
something.

*** gi-fetch

The difference between 'git-fetch', 'git-fetch remote', 'git-fetch
remote branch', and maybe 'git-fetch branch' is confusing.  What's the
common case here?  What's the thing that beginners most need to do?
My own common case is probably 'git-push origin HEAD'.  Maybe do that.

Whatever you do about the remote for gi-push, do the same thing here
too.

** git commands I'm still thinking about

*** git-branch

-m is confusing. It looks like it moves branches, but it moves refs.
Maybe call it gi-move-ref or something.  This is a basic command that
git lacks; the interface on git-update-ref is horrendous.

*** git-mv

*** git-rm

*** git-show

The idea is sound, but I think we can do better here.  But isn't 99%
of the use-case to just do git-log -1?  If so, git-show is probably
okay.

*** git-status

The long output from git-status is helpful to a lot of people.  But I
think the output format could be made simpler or more useful or
something.

I wonder if gi should provide gi-s as an alias for git-status -s?

** gi-add <paths>...

Copies files from the working tree to the index, like git-add.  We
support -u also.

Beginners are confused by this.  Separate gi-add, for adding *new*
files, from gi-stage, for copying changes to the index.  Does gi-add
imply gi-stage, or is it like git-add -N?  Probably avoid git-add -N
since it's still a little bit weird and unfinished.

Calling this "gi-stage" violates the commandment above about confusing
index/stage/cache terminology.  Maybe gi-index instead?  I like this;
it makes clear that gi-reset-index is the opposite of gi-index.

** Totally new commands

*** Something to display the topology of the commit history without
    the details.  It elides sequences of commits that are straight lines.

*** gi-whatnext

    Suggestion for what to do next?  If the index is conflicted,
    suggest gi-reset-index or editing the files followed by gi-index.

** git commands that we will NOT pass through to gi

    git-reset  (what a fucking mess)
      Instead we have gi-discard-changes, gi-reset-index, and gi-go.

    git-pull
      Use gi-fetch plus gi-merge.  Have a gi-pull comand that prints
      out a message that tells you to do that.

    git-init
      Emphasizes that gi is not a different thing than git, but that
      gi is a different way to manipulate *git* repositories.  To make
      a repo, you use git-init, because you are making a *git* repo,
      not some different thing that is called a gi repo.

    git-tag
      Advanced users only.

