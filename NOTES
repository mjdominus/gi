
* PHILOSOPHY

Everything gi *does* is compatible with git.

But it will be pedagogically simple and conceptually clear.

* FOR EXAMPLE

Maybe "git commit file" is convenient.
But it's complex and philosophically confusing.
So we aren't going to do it.
"gi commit" commits THE INDEX.
If you want "git commit file", you know where to find it.

Similarly, "gi commit" is forbidden when the HEAD is detached.
Sometimes it's useful to commit when the HEAD is detached.
If you want to do that, you can use git-commit.

* BASIC CONCEPTS THAT WE EMPHASIZE

HEAD
  head ref
  head commit

The index
  We commit THE INDEX.
  We DO NOT commit "changes".
  We DO NOT commit "a file".

  The terminology here is a mess:

  Do not refer to the index as "the stage" or "the cache".
  Do not refer to indexed changes as "staged" or "cached"?
  Or if you do, pick one and stick with it!
    Don't say "the staged changes" unless you have recently used the longer form
    "The changes staged in the index".

Branches
  A branch is a named commit plus all its ancestor commits.
  Thus some branches contain others.

* Stuff that confuses beginners:

** Detached head

We'll fix this with explicit gi-detach and gi-attach commands.
Instead there's some suite for copying a commit to the index, for
copying the index to the working tree, and gi-go for moving HEAD to a
new commit.

There is always a headref unless you *explicitly* use gi-detach.

** Rejected PUSH

I think this is unavoidable complexity and that git's treatment of
this is correct. Beginners will have to deal with it.  But think about
it anyway; maybe there's some way we can clean it up.

Maybe something to offer helpful advice about what to do.

* COMMANDS

** gi-go <ref>

Attach HEAD to some other ref:

       HEAD now attached to <ref>

The commit pointed to by the old headref doesn't change.

If HEAD was detached, it is attached, that's OK.

** gi-detach

Basically git-checkout HEAD~0.  Message is "HEAD detached" or "HEAD
was already detached".

Need some warning here about possible lost commits.

** gi-branch <name>

Make a new ref at the current head commit.

-a flag attaches to the new ref.

** gi-commit

Commits the index and moves the

Forbidden when in a detached HEAD state.

** gi-move <ref> <commit-ish>

Moves an existing ref to a new commit.  Work could be lost.  Dangerous?
If you do supply this, have it leave behind OLDLOC or something.

** gi-checkout <ref>

Attaches the HEAD to the specified ref.
Then copy the head commit to the index, then to the working directory.

Forbidden if the index or working tree are dirty.

** gi-discard-changes

Discards working tree changes: copies the index to the working tree.

(Optional files: copy only those files?)

** gi-reset-index

Discards index changes: copies the head commit to the index.

(Optional files: copy only those files?)

** git commands that we will pass through to gi unchanged

    gi-cherry-pick
    gi-status
    gi-status--short

    gi-merge
    gi-grep
    gi-log

    Most of the remote repo commands:
    gi-fetch
    gi-clone

** git commands where we should change the interface or the options or something

*** gi-diff

It's hard to guess which two things will be compared.  Try to rationalize the argmuents:

     gi diff commitish-A commitish-B
     gi diff             commitish-B    (commitish-A is taken to be HEAD)
     gi diff INDEX                      ("INDEX" is treated specially)

     gi ix                              (Synonym for 'gi diff INDEX'?
                                         probably not; if they want
                                         that they can make an alias.
                                         Do not multiply entities.)


*** gi-push

I found the distinction between the ref and the remote name confusing.
We can probably clean up the interface here.  Also get a better syntax
for things like "localref:remoteref".  Maybe the remote is *always*
assumed to be 'origin' unless you use a '--remote=foo' option or
something.

Major terminology problem: Git does not have a clear, simple piece of
jargon for distinguishing between:

    1. The ref `foo` in the remote repo
    2. The ref `remote/foo` in the local repo
    3. The ref `foo` in the local repo

These are all related but different.  To understand `git-fetch` and
`git-push` you have to understand that there are three entities here.
But there's not way to talk about them because they don't have names!
But we want to say that `git-fetch` copies 1 to 2, and `git-push`
copies 3 to 1 _and_ to 2.

*** gi-fetch

The difference between 'git-fetch', 'git-fetch remote', 'git-fetch
remote branch', and maybe 'git-fetch branch' is confusing.  What's the
common case here?  What's the thing that beginners most need to do?
My own common case is probably 'git-push origin HEAD'.  Maybe do that.

Whatever you do about the remote for gi-push, do the same thing here
too.

*** gi-rebase

There are at least two problems with rebase.  One is that it
inevitably leads to conflicted pushes.  I don't think that can be
fixed, and I don't think it can be hidden. As discussed above, it must
be faced head-on.

Another problem is that it seems like a scary headfirst dive into
something complex.  We can mitigate this in a couple of ways.

1. gi-copy-branch

This differs from rebase in two ways.  Suppose you have `topic` checked out.
`git-rebase target` does the following:

    1. check out the `target` commit (not `target` itself)
    2. cherry-pick commits from the merge-base up to `topic`, stopping to resolve conflicts
    3. if the cherry-picks are successful, move the `topic` ref to the end of the new branch
    4. check out `topic`.

If successful, it's not clear what happened to the original branch.
Experienced git users can undo this easily with `git reset --hard
ORIG_HEAD` or by using the reflog, but beginners are at sea.  Also,
the jargon is worrisome.  "Rebase"?  What's that?

Instead, we can provide `gi-copy-branch`.  In the same case,
`gi-copy-branch target` does the following:

    1. check out the `target` commit  (exactly the same)
    2. cherry-pick commits the same, but if there is a merge conflict, abort the whole thing
    3. if all the cherry-picks succeed, create a new `topic-copy` ref at the end of the new branch
    4. check out `topic`, which has not moved

End result: you are in exactly the same place, `topic`, which has not
changed.  But you either got an error message (some elaboration of
"couldn't copy all the commits") or else the only new thing is there
is now a new branch, `topic-copy`, on the end of `target`, which you
can check out or examine as usual.  If you decide you don't like it,
you can use `gi-delete-ref topic-copy` to get rid of it.  (Note,
delete *ref*, not delete *branch*.  The _branch_ includes all the
commits back to the initial commit, including everything on `target`.)

(Instead of the `gi-checkout` and `gi-delete-ref` maybe a separate
command: `gi-abandon-original-branch` or something, that moves `topic`
to `topic-copy` and deletes the `topic-copy` ref. Find a better name
for this.)

There can be an option to allow merge resolution instead of instant failure.

The error message can describe the commits that failed, if there were
any, and mention the merge resolution option.  If the user does permit
failed merges, and there is a failure, `gi-wtf` has its work cut out
for it.

2. gi-reorder-commits

Like interactive rebase, but instead of commands, you just get a list
of commits, and edit them into order, they are then rebased into the
requested order.  Unless you provide the expert-level option, a failed
cherry-pick aborts the whole thing.

What are the arguments to this?  Maybe `--back-to commitish` or `-n 6`
to reorder the last 6?  Maybe `--from commitish-A --to commitish-B`?
No, that's no good, because we can't truly support `--to`.

Maybe the result should still be in `foo-copy` and you use
`gi-abandon-original-branch` as with gi-copy-branch.

3. gi-combine-commits

(Or maybe `squash-commits`.  Do _not_ call it `merge-commits`.)

Like `git-rebase`'s squash option.  What is the UI?  Maybe you can just say

      git combine-commits c1 c2 c3 ... cn

and it does a combined reorder plus squash, invokes the editor once
with the combined commit messages from c1...cn, and leaves everything
else in order?  For example if you have commits 1 2 3 4 5 6 7 and you
do `gi combine-commits 2 4 5` then you end up with 1 245 3 6 7.

As usual, a failed merge aborts the whole thing unless you give the special option.

Same thing as above about `gi-abandon-original-branch`.

4. gi-amend

This is just a wrapper around `git commit --amend`.  Replaces the head
commit with the current index.  Maybe instead of moving the headref,
it creates headref`-emended` so you can compare?  This can't fail, but
it could support the `gi-abandon-original-branch` semantics if we
wanted.  It can also easily support an undo.

** git commands I'm still thinking about

*** git-branch

-m is confusing. It looks like it moves branches, but it moves refs.
Maybe call it gi-move-ref or something.  This is a basic command that
git lacks; the interface on git-update-ref is horrendous.

*** git-mv

*** git-rm

*** git-show

The idea is sound, but I think we can do better here.  But isn't 99%
of the use-case to just do git-log -1?  If so, git-show is probably
okay.

*** git-status

The long output from git-status is helpful to a lot of people.  But I
think the output format could be made simpler or more useful or
something.

I wonder if gi should provide gi-s as an alias for git-status -s?

*** gi-add <paths>...

Copies files from the working tree to the index, like git-add.  We
support -u also.

Beginners are confused by this.  Separate gi-add, for adding *new*
files, from gi-stage, for copying changes to the index.  Does gi-add
imply gi-stage, or is it like git-add -N?  Probably avoid git-add -N
since it's still a little bit weird and unfinished.

Calling this "gi-stage" violates the commandment above about confusing
index/stage/cache terminology.  Maybe gi-index instead?  I like this;
it makes clear that gi-reset-index is the opposite of gi-index.

** Totally new commands

All of these are firmly in the "maybe, maybe not" file.

*** Something to display the topology of the commit history without
    the details.  It elides sequences of commits that are straight lines.

*** gi-wtf

    Print a more detailed explanation of the previous error/warning.

    Do it journalist style: Most important paragraph first. If
    there's more to say, end with “OK to stop here, or use `gi wtf`
    again to continue”.  Last paragraph is always “For complete
    details, see `http://gi-wtf.org/gi/blah`”.

*** gi-whatnext

    Suggestion for what to do next?  If the index is conflicted,
    suggest `gi-reset-index` or editing the files followed by `gi-index`.

    Samer Masterson suggests: “reminds me of (Emacs) `vc-next-action`, which
    simply does the next thing instead of asking”.  Look into this.

*** gi-undo

    Each gi command can write a history file that includes a command
    that will perfectly roll back its changes.  `gi-undo` can execute
    the rollback.  This would also allow `gi-history` which describes
    just your `gi` commands without all the intervening `ls`es and
    such.

    Potential difficulty: Changing working directory and other
    environmental changes.  Maybe it's as simple as having each undo
    command start with `cd Whatever-cwd`.

** git commands that we will NOT pass through to gi

    git-reset  (what a fucking mess)
      Instead we have gi-discard-changes, gi-reset-index, and gi-go.

    git-pull Use gi-fetch plus gi-merge.  Have a gi-pull comand that
      prints out a message that tells you to do that. (“Sorry, the
      opposite of `push` is unfortunately `fetch`.”)

    git-init
      Emphasizes that gi is not a different thing than git, but that
      gi is a different way to manipulate *git* repositories.  To make
      a repo, you use git-init, because you are making a *git* repo,
      not some different thing that is called a gi repo.

    git-tag
      Advanced users only.

* Other features:

    gi mode explain-git-commands

      After each gi command, gi will explain which _Git_ commands it
      was using to do the same thing.

      Are there other kinds of mode settings



